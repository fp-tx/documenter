import * as E from '@fp-tx/core/Either'
import { program } from 'commander'

import * as Documenter from './Documenter'
import * as FileService from './FileService'

class DocumenterOptions {
  readonly input: string
  readonly output: string
  constructor(opts: unknown) {
    if (typeof opts !== 'object' || opts === null || Array.isArray(opts)) {
      throw new TypeError(`Received invalid opts type: ${JSON.stringify(opts)}`)
    }
    if (!('input' in opts) || !('output' in opts)) {
      throw new TypeError(`Missing required options, received: ${JSON.stringify(opts)}`)
    }
    if (typeof opts.input !== 'string' || typeof opts.output !== 'string') {
      throw new TypeError(`Input and output must be strings: ${JSON.stringify(opts)}`)
    }
    this.input = opts.input
    this.output = opts.output
  }
}

program
  .name('fp-tx-documenter')
  .description('Generate documentation for a TypeScript package using api-extractor')
  .requiredOption('-i, --input <input>', 'Input JSON file (.api.json) generated by api-extractor')
  .requiredOption('-o, --output <output>', 'the output folder to write the documentation to')
  .parseAsync()
  .then(_ => {
    try {
      const { input, output } = new DocumenterOptions(program.opts())
      const main = Documenter.extractApiPackage(input, output)
      return main({
        ...FileService.FileServiceLive,
        prettierOptions: {
          tabWidth: 2,
          semi: false,
          singleQuote: true,
          trailingComma: 'all',
          printWidth: 120,
        },
      })()
    } catch (e) {
      return E.throwError(e)
    }
  })
  .then(
    E.match(
      err => {
        console.error(err)
        process.exit(1)
      },
      () => {
        console.log('Finished writing documentation')
        process.exit(0)
      },
    ),
  )
  .catch(e => {
    console.error('unhandled error', e)
    process.exit(2)
  })
